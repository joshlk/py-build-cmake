# Examples

- [`minimal`](./minimal):
    Bite-size example using CMake and py-build-cmake to build a Python extension
    module in C. Includes a line-by-line explanation of the configuration file,
    and a discussion of the project's file structure. **‚Üê Start here**
- [`minimal-program`](./minimal-program):
    Using CMake and py-build-cmake to build a C++ program and package it as a
    Python package. The program can then be installed with a single
    `pip install` command, and is automatically added to the `PATH`.
- [`pybind11-project`](./pybind11-project):
    A Python extension module written in C++, with bindings generated by the
    [pybind11](https://github.com/pybind/pybind11) library. This examples more
    closely resembles a real-world package, and includes some nice features such
    as automatic generation of [stubs](https://peps.python.org/pep-0561/) for
    type checking and autocompletion, unit tests using [pytest](https://github.com/pytest-dev/pytest),
    a configuration for [debugging the C++ code](https://tttapa.github.io/py-build-cmake/Debug.html),
    and example configurations for [cross-compilation](https://tttapa.github.io/py-build-cmake/Cross-compilation.html).
- [`nanobind-project`](./nanobind-project): Very similar to `pybind11_project`,
    but using the more modern [nanobind](https://github.com/wjakob/nanobind)
    library to generate the Python bindings instead of pybind11.
- [`minimal-debug-component`](./minimal-debug-component):
    Largely the same as the [minimal](../minimal) example, but uses
    py-build-cmake's `build_component` backend to package the debugging symbols
    in a separate, optional package.

To see how py-build-cmake is used in real-world projects, have a look at the
following packages:

 - [alpaqa](https://github.com/kul-optec/alpaqa/tree/develop)
 - [QPALM](https://github.com/kul-optec/QPALM)
